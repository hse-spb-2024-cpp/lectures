# Общее
http://joeduffyblog.com/2016/02/07/the-error-model/

John Lakos "Defensive Programming Done Right":
https://www.youtube.com/watch?v=1QhtXRMp3Hg
https://www.youtube.com/watch?v=tz2khnjnUx8

Bloomberg error reporting:
https://bloomberg.github.io/bde-resources/doxygen/bde_api_prod/group__bsls__assert.html#4.1
https://bloomberg.github.io/bde-resources/doxygen/bde_api_prod/group__bsls__assert.html#4.2

think-cell's error reporting:
https://youtu.be/Cmud1jO__VA?t=2318

Любая обработка ошибок — это часть алгоритма, контракта и инвариантов программы!
Нет никакого способа добавить обработку ошибок в общем случае, все инструменты
языка (те же исключения) — это лишь инструменты.
Если обработка ошибок важна, её тоже надо продумывать и тестировать.
Нельзя просто "сообщить об ошибке в момент возникновения и обработать где удобно";
это так же неточно, как "решить задачу циклами и ифами".

# Предсказуемые обработанные ошибки
Как `Bad move!` в `lab04-tic-tac-toe` или `Invalid command` в `lab01-executor`:

* В условии разобраны _все_ случаи входных данных.
  * Какие-то случаи считаются "ошибками".
* Надо доказывать, что других случаев не бывает.
* Надо отдельно тестировать.

В зависимости от требований что-то надо обрабатывать, а что-то не надо:

* Некорректные данные
  * На контестах не встречаются
  * В сетевых приложениях нас активно хотят взломать
* Клиент Telegram должен быстро работать, даже если сервер внезапно отвалился
  * Переподключиться?
  * Держать ещё одно соединение в запасе?
* Не удалось записать файл
  * Из-за нехватки места
    * Сообщить пользователю и упасть?
    * Предложить пользователю почистить место на диске?
    * Почистить временные файлы автоматически? А что если там было важное?
    * Переключиться на другой диск?
    * _Позвонить_ администратору?
  * Из-за нехватки прав
    * Честно сказать пользователю?
      * А пользователь-то поймёт? Отдельный вопрос user experience (UX)
    * Обмануть пользователя, а администратору тихо сказать?

Это к тому же сложно тестировать.
Например, можно ввести слой абстракции для всех внешних зависимостей, запретить даже функцию "текущее время".

Как думать:

1. Что случится, когда произойдёт? (не "если")
1. Можно ли с ней сделать что-то разумное с точки зрения _пользователя_?
1. Если да, то как эта обработка ошибки встраивается в алгоритм и архитектуру? (10% общий случай, 90% обработка ошибок - легко)

# Необработанные ошибки
## Предсказуемые
* Некорректный ввод
  * Даже если "гарантируется, что этот файл пишет только наша программа"
  * Оборвалось сетевое соединение
* Не хватило прав доступа

Можно было бы обработать, но неясно как.
Обычно видны в коде: функция возвращает "код ошибки".

### Wide vs narrow contracts для библиотечных функций
Популярная раньше идея (wide contracts):

```c++
int max(const std::vector<int> &v) {
    if (v.empty()) return -1;
    .....
}
std::vector<int> readVector(std::istream &is) {
    int n;
    if (!(is >> n)) return {};  // bad
    std::vector<int> v(n);
    // .....
    return v;
}
```

Проблемы:
1. `-1` может быть корректным значением в векторе.
2. Эти условия может быть несложно проверить _перед_ вызовом функции.
3. Обычно пользователи не думают про то, что вектор может быть пустой. Даже если написано в документации.
   Поэтому у функции проблем нет, а у программы в целом есть.

Лучше делать narrow contract и проверять контракт на входе в функцию:

```c++
int max(const std::vector<int> &v) {
    assert(!v.empty());  // standard C++
    _ASSERT(!v.empty());  // think-cell
    BSLS_ASSERT(!v.empty());  // Bloomberg
    .....
}
std::vector<int> readVector(std::istream &is) {
    int n;
    is >> n;
    assert(is);  // standard C++
    _ASSERT(is);  // think-cell
    BSLS_ASSERT(is);  // Bloomberg
    std::vector<int> v(n);
    // .....
    return v;
}
```

А если хочется делать wide contract, то возвращать отдельное значение:

```c++
std::optional<std::vector<int>> readVector(std::ifstream &is) {
    int n;
    if (!(is >> n)) return std::nullopt;
    std::vector<int> v(n);
    // .....
    return v;
}
// использование
std::vector<int> v = readVector(.....);  // не компилируется, надо разыменовать или проверить на nullopt
```

## Непредсказуемые
Про них можно подумать, но думают редко: https://github.com/kdeldycke/awesome-falsehood

* Кончилось место на диске, память, стек
* Резкое изменение времени
  * Перевод часов вперёд (пропуск часа) или назад (дублирование времени)
  * Подправка рассинхронизации часов
  * Високосный год или секунда

## Что делать
* Проверять. Рекомендация: ронять программу. Например, `assert()`.
* Не проверять. Проблема: не обнаружить, когда случится. Программа будет вести себя непредсказуемо.
  
# Необрабатываемые
Любое UB, нарушение инварианта (двоичный поиск, состояние класса), нарушения контракта функций.

```
void foo(const char *s) {
    printf("%s\n", s);  // Некорректный s.
}
```

Невозможно предотвратить в общем случае.
В C++ _невозможно_ проверить, что указатель/строка корректны.

* Можно пробовать проверять и детектировать (например, `vector::at` вместо `vector::operator[]`),
  но не задетектирует всё (потому что баги) и неясно, что делать после обнаружения
  (мало в чём можно быть уверенным).
* Если случилось, то никаких гарантий, all bets are off.
  Баг в программе точно есть, причём неизвестный, могло упасть где угодно.
  * Нельзя даже быть уверенным, что в другом конце программы нет проблем.
* На самом деле какие-то гарантии могут быть.
  John Lakos называет нарушения контракта "soft undefined behavior" (мягкое неопределённое поведение): всё ещё можно логически вывести поведение программы.
  Но оно легко приводит к "hard undefined behavior" (жёсткое неопределённое поведение): тут уже вообще ничего сделать нельзя.
  * Я слышал, что двадцать лет назад всё ещё можно было, потому что компиляторы были относительно простые и не эксплуатировали UB для оптимизаций.
  * _Принцип кувалды_: https://thephd.dev/c-undefined-behavior-and-the-sledgehammer-guideline

## Что не делать
Не пытайтесь угадать что произошло и что делать дальше:

```c++
bigint operator/(const bigint &a, const bigint &b) {
    if (b == 0) return 0;  // bad
    .....
}
```

Вы надеетесь на три вещи _одновременно_:

1. Программа в принципе может вызвать `a / 0` и потом сделать разумное действие X.
2. Код, вызывающий `a / 0`, в принципе может сделать X.
3. Любой код, вызывающий `a / 0` при получении `0` как результат будет делать X.

По чистому совпадению: в документации или интуиции нигде этого не написано.

TODO: похоже на первую половину этого документа

## Что делать
* Не пытаться предотвратить всё.
* Ставить как можно больше `assert`'ов во всех местах (даже где "очевидно ввод корректный"), _если это несложно_.
